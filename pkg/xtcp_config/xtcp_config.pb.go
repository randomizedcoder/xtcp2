//
// xTCP - config
//
// These are all the structs relating to the TCP diagnotic module in the kernel
//
//
// Build this using buf build ( https://buf.build/ ), see the buf config in the root folder

// https://protobuf.dev/programming-guides/encoding/#structure

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: xtcp_config/v1/xtcp_config.proto

package xtcp_config

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type GetRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRequest) Reset() {
	*x = GetRequest{}
	mi := &file_xtcp_config_v1_xtcp_config_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRequest) ProtoMessage() {}

func (x *GetRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xtcp_config_v1_xtcp_config_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRequest.ProtoReflect.Descriptor instead.
func (*GetRequest) Descriptor() ([]byte, []int) {
	return file_xtcp_config_v1_xtcp_config_proto_rawDescGZIP(), []int{0}
}

type GetResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Config        *XtcpConfig            `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetResponse) Reset() {
	*x = GetResponse{}
	mi := &file_xtcp_config_v1_xtcp_config_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetResponse) ProtoMessage() {}

func (x *GetResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xtcp_config_v1_xtcp_config_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetResponse.ProtoReflect.Descriptor instead.
func (*GetResponse) Descriptor() ([]byte, []int) {
	return file_xtcp_config_v1_xtcp_config_proto_rawDescGZIP(), []int{1}
}

func (x *GetResponse) GetConfig() *XtcpConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

type SetRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Config        *XtcpConfig            `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetRequest) Reset() {
	*x = SetRequest{}
	mi := &file_xtcp_config_v1_xtcp_config_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetRequest) ProtoMessage() {}

func (x *SetRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xtcp_config_v1_xtcp_config_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetRequest.ProtoReflect.Descriptor instead.
func (*SetRequest) Descriptor() ([]byte, []int) {
	return file_xtcp_config_v1_xtcp_config_proto_rawDescGZIP(), []int{2}
}

func (x *SetRequest) GetConfig() *XtcpConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

type SetResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Config        *XtcpConfig            `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetResponse) Reset() {
	*x = SetResponse{}
	mi := &file_xtcp_config_v1_xtcp_config_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetResponse) ProtoMessage() {}

func (x *SetResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xtcp_config_v1_xtcp_config_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetResponse.ProtoReflect.Descriptor instead.
func (*SetResponse) Descriptor() ([]byte, []int) {
	return file_xtcp_config_v1_xtcp_config_proto_rawDescGZIP(), []int{3}
}

func (x *SetResponse) GetConfig() *XtcpConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

type SetPollFrequencyRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Poll frequency
	// This is how often xtcp sends the netlink dump request
	// Recommend not too frequently, so maybe 30s or 60s
	// https://pkg.go.dev/google.golang.org/protobuf/types/known/durationpb
	PollFrequency *durationpb.Duration `protobuf:"bytes,20,opt,name=poll_frequency,json=pollFrequency,proto3" json:"poll_frequency,omitempty"`
	// Poll timeout per name space
	// Must be less than the poll frequency
	PollTimeout   *durationpb.Duration `protobuf:"bytes,30,opt,name=poll_timeout,json=pollTimeout,proto3" json:"poll_timeout,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetPollFrequencyRequest) Reset() {
	*x = SetPollFrequencyRequest{}
	mi := &file_xtcp_config_v1_xtcp_config_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetPollFrequencyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetPollFrequencyRequest) ProtoMessage() {}

func (x *SetPollFrequencyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xtcp_config_v1_xtcp_config_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetPollFrequencyRequest.ProtoReflect.Descriptor instead.
func (*SetPollFrequencyRequest) Descriptor() ([]byte, []int) {
	return file_xtcp_config_v1_xtcp_config_proto_rawDescGZIP(), []int{4}
}

func (x *SetPollFrequencyRequest) GetPollFrequency() *durationpb.Duration {
	if x != nil {
		return x.PollFrequency
	}
	return nil
}

func (x *SetPollFrequencyRequest) GetPollTimeout() *durationpb.Duration {
	if x != nil {
		return x.PollTimeout
	}
	return nil
}

type SetPollFrequencyResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Config        *XtcpConfig            `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetPollFrequencyResponse) Reset() {
	*x = SetPollFrequencyResponse{}
	mi := &file_xtcp_config_v1_xtcp_config_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetPollFrequencyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetPollFrequencyResponse) ProtoMessage() {}

func (x *SetPollFrequencyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xtcp_config_v1_xtcp_config_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetPollFrequencyResponse.ProtoReflect.Descriptor instead.
func (*SetPollFrequencyResponse) Descriptor() ([]byte, []int) {
	return file_xtcp_config_v1_xtcp_config_proto_rawDescGZIP(), []int{5}
}

func (x *SetPollFrequencyResponse) GetConfig() *XtcpConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

// xtcp configuration
type XtcpConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Netlink socket timeout in milliseconds
	// Recommend 5000
	NlTimeoutMilliseconds uint64 `protobuf:"varint,10,opt,name=nl_timeout_milliseconds,json=nlTimeoutMilliseconds,proto3" json:"nl_timeout_milliseconds,omitempty"`
	// Poll frequency
	// This is how often xtcp sends the netlink dump request
	// Recommend not too frequently, so maybe 30s or 60s
	// https://pkg.go.dev/google.golang.org/protobuf/types/known/durationpb
	PollFrequency *durationpb.Duration `protobuf:"bytes,20,opt,name=poll_frequency,json=pollFrequency,proto3" json:"poll_frequency,omitempty"`
	// Poll timeout per name space
	// Must be less than the poll frequency
	PollTimeout *durationpb.Duration `protobuf:"bytes,30,opt,name=poll_timeout,json=pollTimeout,proto3" json:"poll_timeout,omitempty"`
	// Maximum number of loops, or zero (0) for forever
	MaxLoops uint64 `protobuf:"varint,40,opt,name=max_loops,json=maxLoops,proto3" json:"max_loops,omitempty"`
	// Netlinker goroutines per netlink socket ( recommend 1,2,4 range )
	// Netlinkers read the tcp-diag response messages from the netlink socket
	// If you have a large number of
	Netlinkers uint32 `protobuf:"varint,50,opt,name=netlinkers,proto3" json:"netlinkers,omitempty"`
	// netlinkerDoneCh channel size
	// This channel is used between the netlinkers and the poller
	// Check the prom counter to see if the channel is too small
	// d.pC.WithLabelValues("Deserialize", "netlinkerDoneCh", "error").Inc()
	NetlinkersDoneChanSize uint32 `protobuf:"varint,51,opt,name=netlinkers_done_chan_size,json=netlinkersDoneChanSize,proto3" json:"netlinkers_done_chan_size,omitempty"`
	// nlmsg_seq sequence number (start). This gets incremented.
	NlmsgSeq uint32 `protobuf:"varint,60,opt,name=nlmsg_seq,json=nlmsgSeq,proto3" json:"nlmsg_seq,omitempty"`
	// netlinker packetSize.  buffer size = packetSize * packetSizeMply. Use zero (0) for syscall.Getpagesize()
	// recommend using 0
	PacketSize uint64 `protobuf:"varint,70,opt,name=packet_size,json=packetSize,proto3" json:"packet_size,omitempty"`
	// netlinker packetSize multiplier.  buffer size = packetSize * packetSizeMply
	PacketSizeMply uint32 `protobuf:"varint,80,opt,name=packet_size_mply,json=packetSizeMply,proto3" json:"packet_size_mply,omitempty"`
	// Write netlink packets to writeFiles number of files ( to generate test data ) per netlinker
	// xtcp will capture this many Netlink response packets when it starts
	// This is PER netlinker
	WriteFiles uint32 `protobuf:"varint,90,opt,name=write_files,json=writeFiles,proto3" json:"write_files,omitempty"`
	// Write files path
	CapturePath string `protobuf:"bytes,100,opt,name=capture_path,json=capturePath,proto3" json:"capture_path,omitempty"`
	// modulus. Report every X socket diag messages to output
	Modulus uint64 `protobuf:"varint,110,opt,name=modulus,proto3" json:"modulus,omitempty"`
	// Marshalling of the exported data (protobufList,json,prototext)
	MarshalTo string `protobuf:"bytes,120,opt,name=marshal_to,json=marshalTo,proto3" json:"marshal_to,omitempty"`
	// protobufListMarshal can optionally not length delimit
	ProtobufListLengthDelimit bool `protobuf:"varint,121,opt,name=protobuf_list_length_delimit,json=protobufListLengthDelimit,proto3" json:"protobuf_list_length_delimit,omitempty"`
	// kafka:127.0.0.1:9092, udp:127.0.0.1:13000, or nsq:127.0.0.1:4150, or null:
	Dest string `protobuf:"bytes,130,opt,name=dest,proto3" json:"dest,omitempty"`
	// Write marhselled data to writeFiles number of files ( to allow debugging of the serialization )
	// xtcp will capture this many examples of the marshalled data
	// This is PER poller
	DestWriteFiles uint32 `protobuf:"varint,135,opt,name=dest_write_files,json=destWriteFiles,proto3" json:"dest_write_files,omitempty"`
	// Kafka or NSQ topic
	Topic string `protobuf:"bytes,140,opt,name=topic,proto3" json:"topic,omitempty"`
	// XtcpProtoFile
	XtcpProtoFile string `protobuf:"bytes,143,opt,name=xtcp_proto_file,json=xtcpProtoFile,proto3" json:"xtcp_proto_file,omitempty"`
	// Kafka schema registry url
	KafkaSchemaUrl string `protobuf:"bytes,145,opt,name=kafka_schema_url,json=kafkaSchemaUrl,proto3" json:"kafka_schema_url,omitempty"`
	// Kafka Produce context timeout.  Use 0 for no context timeout
	// Recommend a small timeout, like 1-2 seconds
	// kgo seems to have a bug, because the timeout is always expired
	KafkaProduceTimeout *durationpb.Duration `protobuf:"bytes,150,opt,name=kafka_produce_timeout,json=kafkaProduceTimeout,proto3" json:"kafka_produce_timeout,omitempty"`
	// DebugLevel
	DebugLevel uint32 `protobuf:"varint,160,opt,name=debug_level,json=debugLevel,proto3" json:"debug_level,omitempty"`
	// Label applied to the protobuf
	Label string `protobuf:"bytes,170,opt,name=label,proto3" json:"label,omitempty"`
	// Tag applied to the protobuf
	Tag string `protobuf:"bytes,180,opt,name=tag,proto3" json:"tag,omitempty"`
	// GRPC listening port
	GrpcPort             uint32                `protobuf:"varint,190,opt,name=grpc_port,json=grpcPort,proto3" json:"grpc_port,omitempty"`
	EnabledDeserializers *EnabledDeserializers `protobuf:"bytes,200,opt,name=enabled_deserializers,json=enabledDeserializers,proto3" json:"enabled_deserializers,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *XtcpConfig) Reset() {
	*x = XtcpConfig{}
	mi := &file_xtcp_config_v1_xtcp_config_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *XtcpConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*XtcpConfig) ProtoMessage() {}

func (x *XtcpConfig) ProtoReflect() protoreflect.Message {
	mi := &file_xtcp_config_v1_xtcp_config_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use XtcpConfig.ProtoReflect.Descriptor instead.
func (*XtcpConfig) Descriptor() ([]byte, []int) {
	return file_xtcp_config_v1_xtcp_config_proto_rawDescGZIP(), []int{6}
}

func (x *XtcpConfig) GetNlTimeoutMilliseconds() uint64 {
	if x != nil {
		return x.NlTimeoutMilliseconds
	}
	return 0
}

func (x *XtcpConfig) GetPollFrequency() *durationpb.Duration {
	if x != nil {
		return x.PollFrequency
	}
	return nil
}

func (x *XtcpConfig) GetPollTimeout() *durationpb.Duration {
	if x != nil {
		return x.PollTimeout
	}
	return nil
}

func (x *XtcpConfig) GetMaxLoops() uint64 {
	if x != nil {
		return x.MaxLoops
	}
	return 0
}

func (x *XtcpConfig) GetNetlinkers() uint32 {
	if x != nil {
		return x.Netlinkers
	}
	return 0
}

func (x *XtcpConfig) GetNetlinkersDoneChanSize() uint32 {
	if x != nil {
		return x.NetlinkersDoneChanSize
	}
	return 0
}

func (x *XtcpConfig) GetNlmsgSeq() uint32 {
	if x != nil {
		return x.NlmsgSeq
	}
	return 0
}

func (x *XtcpConfig) GetPacketSize() uint64 {
	if x != nil {
		return x.PacketSize
	}
	return 0
}

func (x *XtcpConfig) GetPacketSizeMply() uint32 {
	if x != nil {
		return x.PacketSizeMply
	}
	return 0
}

func (x *XtcpConfig) GetWriteFiles() uint32 {
	if x != nil {
		return x.WriteFiles
	}
	return 0
}

func (x *XtcpConfig) GetCapturePath() string {
	if x != nil {
		return x.CapturePath
	}
	return ""
}

func (x *XtcpConfig) GetModulus() uint64 {
	if x != nil {
		return x.Modulus
	}
	return 0
}

func (x *XtcpConfig) GetMarshalTo() string {
	if x != nil {
		return x.MarshalTo
	}
	return ""
}

func (x *XtcpConfig) GetProtobufListLengthDelimit() bool {
	if x != nil {
		return x.ProtobufListLengthDelimit
	}
	return false
}

func (x *XtcpConfig) GetDest() string {
	if x != nil {
		return x.Dest
	}
	return ""
}

func (x *XtcpConfig) GetDestWriteFiles() uint32 {
	if x != nil {
		return x.DestWriteFiles
	}
	return 0
}

func (x *XtcpConfig) GetTopic() string {
	if x != nil {
		return x.Topic
	}
	return ""
}

func (x *XtcpConfig) GetXtcpProtoFile() string {
	if x != nil {
		return x.XtcpProtoFile
	}
	return ""
}

func (x *XtcpConfig) GetKafkaSchemaUrl() string {
	if x != nil {
		return x.KafkaSchemaUrl
	}
	return ""
}

func (x *XtcpConfig) GetKafkaProduceTimeout() *durationpb.Duration {
	if x != nil {
		return x.KafkaProduceTimeout
	}
	return nil
}

func (x *XtcpConfig) GetDebugLevel() uint32 {
	if x != nil {
		return x.DebugLevel
	}
	return 0
}

func (x *XtcpConfig) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *XtcpConfig) GetTag() string {
	if x != nil {
		return x.Tag
	}
	return ""
}

func (x *XtcpConfig) GetGrpcPort() uint32 {
	if x != nil {
		return x.GrpcPort
	}
	return 0
}

func (x *XtcpConfig) GetEnabledDeserializers() *EnabledDeserializers {
	if x != nil {
		return x.EnabledDeserializers
	}
	return nil
}

type EnabledDeserializers struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Enabled       map[string]bool        `protobuf:"bytes,1,rep,name=enabled,proto3" json:"enabled,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnabledDeserializers) Reset() {
	*x = EnabledDeserializers{}
	mi := &file_xtcp_config_v1_xtcp_config_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnabledDeserializers) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnabledDeserializers) ProtoMessage() {}

func (x *EnabledDeserializers) ProtoReflect() protoreflect.Message {
	mi := &file_xtcp_config_v1_xtcp_config_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnabledDeserializers.ProtoReflect.Descriptor instead.
func (*EnabledDeserializers) Descriptor() ([]byte, []int) {
	return file_xtcp_config_v1_xtcp_config_proto_rawDescGZIP(), []int{7}
}

func (x *EnabledDeserializers) GetEnabled() map[string]bool {
	if x != nil {
		return x.Enabled
	}
	return nil
}

var File_xtcp_config_v1_xtcp_config_proto protoreflect.FileDescriptor

const file_xtcp_config_v1_xtcp_config_proto_rawDesc = "" +
	"\n" +
	" xtcp_config/v1/xtcp_config.proto\x12\x0extcp_config.v1\x1a\x1egoogle/protobuf/duration.proto\x1a\x1cgoogle/api/annotations.proto\x1a\x1bbuf/validate/validate.proto\"\f\n" +
	"\n" +
	"GetRequest\"A\n" +
	"\vGetResponse\x122\n" +
	"\x06config\x18\x01 \x01(\v2\x1a.xtcp_config.v1.XtcpConfigR\x06config\"@\n" +
	"\n" +
	"SetRequest\x122\n" +
	"\x06config\x18\x01 \x01(\v2\x1a.xtcp_config.v1.XtcpConfigR\x06config\"A\n" +
	"\vSetResponse\x122\n" +
	"\x06config\x18\x01 \x01(\v2\x1a.xtcp_config.v1.XtcpConfigR\x06config\"\xb4\x02\n" +
	"\x17SetPollFrequencyRequest\x12S\n" +
	"\x0epoll_frequency\x18\x14 \x01(\v2\x19.google.protobuf.DurationB\x11\xbaH\x0e\xc8\x01\x01\xaa\x01\b\"\x04\b\x80\xf5$2\x00R\rpollFrequency\x12O\n" +
	"\fpoll_timeout\x18\x1e \x01(\v2\x19.google.protobuf.DurationB\x11\xbaH\x0e\xc8\x01\x01\xaa\x01\b\"\x04\b\x80\xf5$2\x00R\vpollTimeout:s\xbaHp\x1an\n" +
	"\x0fXtcpConfig.poll\x122Poll timeout must be less than poll poll_frequency\x1a'this.poll_timeout < this.poll_frequency\"N\n" +
	"\x18SetPollFrequencyResponse\x122\n" +
	"\x06config\x18\x01 \x01(\v2\x1a.xtcp_config.v1.XtcpConfigR\x06config\"\x83\f\n" +
	"\n" +
	"XtcpConfig\x12F\n" +
	"\x17nl_timeout_milliseconds\x18\n" +
	" \x01(\x04B\x0e\xbaH\v\xc8\x01\x012\x06\x18\xa0\x8d\x06(\x00R\x15nlTimeoutMilliseconds\x12S\n" +
	"\x0epoll_frequency\x18\x14 \x01(\v2\x19.google.protobuf.DurationB\x11\xbaH\x0e\xc8\x01\x01\xaa\x01\b\"\x04\b\x80\xf5$*\x00R\rpollFrequency\x12O\n" +
	"\fpoll_timeout\x18\x1e \x01(\v2\x19.google.protobuf.DurationB\x11\xbaH\x0e\xc8\x01\x01\xaa\x01\b\"\x04\b\x80\xf5$*\x00R\vpollTimeout\x12+\n" +
	"\tmax_loops\x18( \x01(\x04B\x0e\xbaH\v\xc8\x01\x002\x06\x18\xa0\x8d\x06(\x00R\bmaxLoops\x12,\n" +
	"\n" +
	"netlinkers\x182 \x01(\rB\f\xbaH\t\xc8\x01\x01*\x04\x18d(\x01R\n" +
	"netlinkers\x12H\n" +
	"\x19netlinkers_done_chan_size\x183 \x01(\rB\r\xbaH\n" +
	"\xc8\x01\x01*\x05\x18\xe8\a(\x01R\x16netlinkersDoneChanSize\x12*\n" +
	"\tnlmsg_seq\x18< \x01(\rB\r\xbaH\n" +
	"\xc8\x01\x01*\x05\x18\x90N(\x00R\bnlmsgSeq\x12/\n" +
	"\vpacket_size\x18F \x01(\x04B\x0e\xbaH\v\xc8\x01\x002\x06\x18\xc0\x84=(\x00R\n" +
	"packetSize\x126\n" +
	"\x10packet_size_mply\x18P \x01(\rB\f\xbaH\t\xc8\x01\x00*\x04\x18d(\x00R\x0epacketSizeMply\x12.\n" +
	"\vwrite_files\x18Z \x01(\rB\r\xbaH\n" +
	"\xc8\x01\x00*\x05\x18\xe8\a(\x00R\n" +
	"writeFiles\x12/\n" +
	"\fcapture_path\x18d \x01(\tB\f\xbaH\t\xc8\x01\x00r\x04\x10\x01\x18PR\vcapturePath\x12(\n" +
	"\amodulus\x18n \x01(\x04B\x0e\xbaH\v\xc8\x01\x012\x06\x18\xc0\x84=(\x01R\amodulus\x12+\n" +
	"\n" +
	"marshal_to\x18x \x01(\tB\f\xbaH\t\xc8\x01\x01r\x04\x10\x04\x18(R\tmarshalTo\x12G\n" +
	"\x1cprotobuf_list_length_delimit\x18y \x01(\bB\x06\xbaH\x03\xc8\x01\x00R\x19protobufListLengthDelimit\x12!\n" +
	"\x04dest\x18\x82\x01 \x01(\tB\f\xbaH\t\xc8\x01\x01r\x04\x10\x04\x18(R\x04dest\x128\n" +
	"\x10dest_write_files\x18\x87\x01 \x01(\rB\r\xbaH\n" +
	"\xc8\x01\x00*\x05\x18\xe8\a(\x00R\x0edestWriteFiles\x12#\n" +
	"\x05topic\x18\x8c\x01 \x01(\tB\f\xbaH\t\xc8\x01\x00r\x04\x10\x01\x18(R\x05topic\x125\n" +
	"\x0fxtcp_proto_file\x18\x8f\x01 \x01(\tB\f\xbaH\t\xc8\x01\x00r\x04\x10\x01\x18PR\rxtcpProtoFile\x127\n" +
	"\x10kafka_schema_url\x18\x91\x01 \x01(\tB\f\xbaH\t\xc8\x01\x00r\x04\x10\x01\x18<R\x0ekafkaSchemaUrl\x12`\n" +
	"\x15kafka_produce_timeout\x18\x96\x01 \x01(\v2\x19.google.protobuf.DurationB\x10\xbaH\r\xc8\x01\x00\xaa\x01\a\"\x03\b\xd8\x042\x00R\x13kafkaProduceTimeout\x12/\n" +
	"\vdebug_level\x18\xa0\x01 \x01(\rB\r\xbaH\n" +
	"\xc8\x01\x01*\x05\x18\xe8\a(\x00R\n" +
	"debugLevel\x12!\n" +
	"\x05label\x18\xaa\x01 \x01(\tB\n" +
	"\xbaH\a\xc8\x01\x00r\x02\x18(R\x05label\x12\x1d\n" +
	"\x03tag\x18\xb4\x01 \x01(\tB\n" +
	"\xbaH\a\xc8\x01\x00r\x02\x18(R\x03tag\x12,\n" +
	"\tgrpc_port\x18\xbe\x01 \x01(\rB\x0e\xbaH\v\xc8\x01\x01*\x06\x18\xff\xff\x03(\x01R\bgrpcPort\x12b\n" +
	"\x15enabled_deserializers\x18\xc8\x01 \x01(\v2$.xtcp_config.v1.EnabledDeserializersB\x06\xbaH\x03\xc8\x01\x00R\x14enabledDeserializers:s\xbaHp\x1an\n" +
	"\x0fXtcpConfig.poll\x122Poll timeout must be less than poll poll_frequency\x1a'this.poll_frequency > this.poll_timeout\"\x9f\x01\n" +
	"\x14EnabledDeserializers\x12K\n" +
	"\aenabled\x18\x01 \x03(\v21.xtcp_config.v1.EnabledDeserializers.EnabledEntryR\aenabled\x1a:\n" +
	"\fEnabledEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\bR\x05value:\x028\x012\xe1\x02\n" +
	"\rConfigService\x12]\n" +
	"\x03Get\x12\x1a.xtcp_config.v1.GetRequest\x1a\x1b.xtcp_config.v1.GetResponse\"\x1d\x82\xd3\xe4\x93\x02\x17:\x01*\x1a\x12/ConfigService/Get\x12]\n" +
	"\x03Set\x12\x1a.xtcp_config.v1.SetRequest\x1a\x1b.xtcp_config.v1.SetResponse\"\x1d\x82\xd3\xe4\x93\x02\x17:\x01*\x1a\x12/ConfigService/Set\x12\x91\x01\n" +
	"\x10SetPollFrequency\x12'.xtcp_config.v1.SetPollFrequencyRequest\x1a(.xtcp_config.v1.SetPollFrequencyResponse\"*\x82\xd3\xe4\x93\x02$:\x01*\x1a\x1f/ConfigService/SetPollFrequencyB\x8d\x01\n" +
	"\x12com.xtcp_config.v1B\x0fXtcpConfigProtoP\x01Z\x11./pkg/xtcp_config\xa2\x02\x03XXX\xaa\x02\rXtcpConfig.V1\xca\x02\rXtcpConfig\\V1\xe2\x02\x19XtcpConfig\\V1\\GPBMetadata\xea\x02\x0eXtcpConfig::V1b\x06proto3"

var (
	file_xtcp_config_v1_xtcp_config_proto_rawDescOnce sync.Once
	file_xtcp_config_v1_xtcp_config_proto_rawDescData []byte
)

func file_xtcp_config_v1_xtcp_config_proto_rawDescGZIP() []byte {
	file_xtcp_config_v1_xtcp_config_proto_rawDescOnce.Do(func() {
		file_xtcp_config_v1_xtcp_config_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_xtcp_config_v1_xtcp_config_proto_rawDesc), len(file_xtcp_config_v1_xtcp_config_proto_rawDesc)))
	})
	return file_xtcp_config_v1_xtcp_config_proto_rawDescData
}

var file_xtcp_config_v1_xtcp_config_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_xtcp_config_v1_xtcp_config_proto_goTypes = []any{
	(*GetRequest)(nil),               // 0: xtcp_config.v1.GetRequest
	(*GetResponse)(nil),              // 1: xtcp_config.v1.GetResponse
	(*SetRequest)(nil),               // 2: xtcp_config.v1.SetRequest
	(*SetResponse)(nil),              // 3: xtcp_config.v1.SetResponse
	(*SetPollFrequencyRequest)(nil),  // 4: xtcp_config.v1.SetPollFrequencyRequest
	(*SetPollFrequencyResponse)(nil), // 5: xtcp_config.v1.SetPollFrequencyResponse
	(*XtcpConfig)(nil),               // 6: xtcp_config.v1.XtcpConfig
	(*EnabledDeserializers)(nil),     // 7: xtcp_config.v1.EnabledDeserializers
	nil,                              // 8: xtcp_config.v1.EnabledDeserializers.EnabledEntry
	(*durationpb.Duration)(nil),      // 9: google.protobuf.Duration
}
var file_xtcp_config_v1_xtcp_config_proto_depIdxs = []int32{
	6,  // 0: xtcp_config.v1.GetResponse.config:type_name -> xtcp_config.v1.XtcpConfig
	6,  // 1: xtcp_config.v1.SetRequest.config:type_name -> xtcp_config.v1.XtcpConfig
	6,  // 2: xtcp_config.v1.SetResponse.config:type_name -> xtcp_config.v1.XtcpConfig
	9,  // 3: xtcp_config.v1.SetPollFrequencyRequest.poll_frequency:type_name -> google.protobuf.Duration
	9,  // 4: xtcp_config.v1.SetPollFrequencyRequest.poll_timeout:type_name -> google.protobuf.Duration
	6,  // 5: xtcp_config.v1.SetPollFrequencyResponse.config:type_name -> xtcp_config.v1.XtcpConfig
	9,  // 6: xtcp_config.v1.XtcpConfig.poll_frequency:type_name -> google.protobuf.Duration
	9,  // 7: xtcp_config.v1.XtcpConfig.poll_timeout:type_name -> google.protobuf.Duration
	9,  // 8: xtcp_config.v1.XtcpConfig.kafka_produce_timeout:type_name -> google.protobuf.Duration
	7,  // 9: xtcp_config.v1.XtcpConfig.enabled_deserializers:type_name -> xtcp_config.v1.EnabledDeserializers
	8,  // 10: xtcp_config.v1.EnabledDeserializers.enabled:type_name -> xtcp_config.v1.EnabledDeserializers.EnabledEntry
	0,  // 11: xtcp_config.v1.ConfigService.Get:input_type -> xtcp_config.v1.GetRequest
	2,  // 12: xtcp_config.v1.ConfigService.Set:input_type -> xtcp_config.v1.SetRequest
	4,  // 13: xtcp_config.v1.ConfigService.SetPollFrequency:input_type -> xtcp_config.v1.SetPollFrequencyRequest
	1,  // 14: xtcp_config.v1.ConfigService.Get:output_type -> xtcp_config.v1.GetResponse
	3,  // 15: xtcp_config.v1.ConfigService.Set:output_type -> xtcp_config.v1.SetResponse
	5,  // 16: xtcp_config.v1.ConfigService.SetPollFrequency:output_type -> xtcp_config.v1.SetPollFrequencyResponse
	14, // [14:17] is the sub-list for method output_type
	11, // [11:14] is the sub-list for method input_type
	11, // [11:11] is the sub-list for extension type_name
	11, // [11:11] is the sub-list for extension extendee
	0,  // [0:11] is the sub-list for field type_name
}

func init() { file_xtcp_config_v1_xtcp_config_proto_init() }
func file_xtcp_config_v1_xtcp_config_proto_init() {
	if File_xtcp_config_v1_xtcp_config_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_xtcp_config_v1_xtcp_config_proto_rawDesc), len(file_xtcp_config_v1_xtcp_config_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   9,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_xtcp_config_v1_xtcp_config_proto_goTypes,
		DependencyIndexes: file_xtcp_config_v1_xtcp_config_proto_depIdxs,
		MessageInfos:      file_xtcp_config_v1_xtcp_config_proto_msgTypes,
	}.Build()
	File_xtcp_config_v1_xtcp_config_proto = out.File
	file_xtcp_config_v1_xtcp_config_proto_goTypes = nil
	file_xtcp_config_v1_xtcp_config_proto_depIdxs = nil
}
